// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";

/**
 * @title Governance
 * @dev Contract for decentralized governance proposals and voting
 */
contract Governance {
    // Token used for voting weight
    IERC20 public governanceToken;
    
    // Enum for proposal types
    enum ProposalType {
        GENERAL,
        PARAMETER_CHANGE,
        FUND_ALLOCATION,
        EMERGENCY
    }

    // Enum for proposal status
    enum ProposalStatus {
        PENDING,
        ACTIVE,
        SUCCEEDED,
        DEFEATED,
        EXECUTED,
        CANCELED,
        EXPIRED
    }

    // Enum for vote support
    enum VoteSupport {
        AGAINST,
        FOR,
        ABSTAIN
    }

    // Struct for proposal
    struct Proposal {
        uint256 id;
        address creator;
        string title;
        string description;
        ProposalType proposalType;
        uint256 startTime;
        uint256 endTime;
        uint256 yesVotes;
        uint256 noVotes;
        uint256 abstainVotes;
        address[] targets;
        uint256[] values;
        bytes[] calldata_;
        string metadataURI;
        ProposalStatus status;
        mapping(address => bool) hasVoted;
        mapping(address => VoteSupport) votes;
        mapping(address => uint256) voteWeights;
        uint256 quorum;
    }
    
    // Delegation
    mapping(address => address) public delegations;
    mapping(address => uint256) public delegatedPower;

    // State variables
    uint256 public proposalCount;
    mapping(uint256 => Proposal) public proposals;
    uint256 public minimumVotingPeriod;
    uint256 public quorumPercentage; // Percentage of total supply needed (0-100)

    // Events
    event ProposalCreated(
        uint256 indexed proposalId,
        address indexed creator,
        string title,
        uint256 startTime,
        uint256 endTime
    );

    event VoteCast(
        address indexed voter,
        uint256 indexed proposalId,
        uint8 support,
        uint256 weight
    );

    event ProposalStatusChanged(
        uint256 indexed proposalId,
        ProposalStatus status
    );
    
    event DelegationChanged(
        address indexed delegator,
        address indexed delegatee
    );

    // Custom errors
    error ProposalNotFound();
    error InvalidProposalTimeline();
    error VotingPeriodTooShort();
    error ProposalNotActive();
    error AlreadyVoted();
    error InvalidDelegation();

    /**
     * @dev Constructor sets the minimum voting period and governance token
     * @param _minimumVotingPeriod Minimum time in seconds that a proposal must be open for voting
     * @param _governanceToken Address of the governance token used for voting
     * @param _quorumPercentage Percentage of total supply needed for quorum (0-100)
     */
    constructor(
        uint256 _minimumVotingPeriod,
        address _governanceToken,
        uint256 _quorumPercentage
    ) {
        minimumVotingPeriod = _minimumVotingPeriod;
        governanceToken = IERC20(_governanceToken);
        quorumPercentage = _quorumPercentage;
    }

    /**
     * @dev Create a new governance proposal
     * @param _title Title of the proposal
     * @param _description Description of the proposal
     * @param _proposalType Type of the proposal (GENERAL, PARAMETER_CHANGE, etc.)
     * @param _startTime Start time for voting (unix timestamp)
     * @param _endTime End time for voting (unix timestamp)
     * @param _targets Contract addresses to call if proposal is executed
     * @param _values ETH values to send with each call
     * @param _calldata Function data for each call
     * @param _metadataURI URI for any additional metadata
     * @return proposalId The ID of the created proposal
     */
    function createProposal(
        string memory _title,
        string memory _description,
        ProposalType _proposalType,
        uint256 _startTime,
        uint256 _endTime,
        address[] memory _targets,
        uint256[] memory _values,
        bytes[] memory _calldata,
        string memory _metadataURI
    ) external returns (uint256 proposalId) {
        // Validate proposal timeline
        if (_endTime <= _startTime) {
            revert InvalidProposalTimeline();
        }

        // Validate voting period
        if (_endTime - _startTime < minimumVotingPeriod) {
            revert VotingPeriodTooShort();
        }

        // Create new proposal
        proposalId = proposalCount++;
        Proposal storage proposal = proposals[proposalId];
        
        proposal.id = proposalId;
        proposal.creator = msg.sender;
        proposal.title = _title;
        proposal.description = _description;
        proposal.proposalType = _proposalType;
        proposal.startTime = _startTime;
        proposal.endTime = _endTime;
        proposal.targets = _targets;
        proposal.values = _values;
        proposal.calldata_ = _calldata;
        proposal.metadataURI = _metadataURI;
        
        // Calculate quorum as percentage of total supply
        uint256 totalSupply = governanceToken.totalSupply();
        proposal.quorum = (totalSupply * quorumPercentage) / 100;
        
        // Set initial status
        if (_startTime > block.timestamp) {
            proposal.status = ProposalStatus.PENDING;
        } else {
            proposal.status = ProposalStatus.ACTIVE;
        }

        // Emit event
        emit ProposalCreated(
            proposalId,
            msg.sender,
            _title,
            _startTime,
            _endTime
        );

        return proposalId;
    }

    /**
     * @dev Vote on a proposal with token weight
     * @param _proposalId ID of the proposal
     * @param _support Support value (0=Against, 1=For, 2=Abstain)
     */
    function vote(uint256 _proposalId, VoteSupport _support) external {
        // Validate proposal exists
        if (_proposalId >= proposalCount) {
            revert ProposalNotFound();
        }

        Proposal storage proposal = proposals[_proposalId];

        // Check if proposal is active
        if (
            proposal.status != ProposalStatus.ACTIVE ||
            block.timestamp < proposal.startTime ||
            block.timestamp > proposal.endTime
        ) {
            revert ProposalNotActive();
        }

        // Check if voter has already voted
        if (proposal.hasVoted[msg.sender]) {
            revert AlreadyVoted();
        }

        // Calculate voting weight: own balance + delegated power
        uint256 voteWeight = governanceToken.balanceOf(msg.sender) + delegatedPower[msg.sender];
        
        // Record vote
        proposal.hasVoted[msg.sender] = true;
        proposal.votes[msg.sender] = _support;
        proposal.voteWeights[msg.sender] = voteWeight;

        // Update vote counts with token weight
        if (_support == VoteSupport.FOR) {
            proposal.yesVotes += voteWeight;
        } else if (_support == VoteSupport.AGAINST) {
            proposal.noVotes += voteWeight;
        } else {
            proposal.abstainVotes += voteWeight;
        }

        // Emit event
        emit VoteCast(msg.sender, _proposalId, uint8(_support), voteWeight);
    }

    /**
     * @dev Update proposal status based on current time and votes
     * @param _proposalId ID of the proposal
     */
    function updateProposalStatus(uint256 _proposalId) external {
        if (_proposalId >= proposalCount) {
            revert ProposalNotFound();
        }

        Proposal storage proposal = proposals[_proposalId];
        ProposalStatus currentStatus = proposal.status;

        // Update status based on current time
        if (currentStatus == ProposalStatus.PENDING && block.timestamp >= proposal.startTime) {
            proposal.status = ProposalStatus.ACTIVE;
        } else if (currentStatus == ProposalStatus.ACTIVE && block.timestamp > proposal.endTime) {
            // Check if quorum was reached
            uint256 totalVotes = proposal.yesVotes + proposal.noVotes + proposal.abstainVotes;
            
            if (totalVotes < proposal.quorum) {
                // Quorum not reached
                proposal.status = ProposalStatus.DEFEATED;
            } else {
                // Determine if proposal succeeded or was defeated
                if (proposal.yesVotes > proposal.noVotes) {
                    proposal.status = ProposalStatus.SUCCEEDED;
                } else {
                    proposal.status = ProposalStatus.DEFEATED;
                }
            }
        }

        // Only emit event if status changed
        if (currentStatus != proposal.status) {
            emit ProposalStatusChanged(_proposalId, proposal.status);
        }
    }
    
    /**
     * @dev Delegate voting power to another address
     * @param _delegatee Address to delegate voting power to
     */
    function delegate(address _delegatee) external {
        // Cannot delegate to self or zero address
        if (_delegatee == msg.sender || _delegatee == address(0)) {
            revert InvalidDelegation();
        }
        
        // Remove previous delegation
        address currentDelegatee = delegations[msg.sender];
        if (currentDelegatee != address(0)) {
            delegatedPower[currentDelegatee] -= governanceToken.balanceOf(msg.sender);
        }
        
        // Set new delegation
        delegations[msg.sender] = _delegatee;
        delegatedPower[_delegatee] += governanceToken.balanceOf(msg.sender);
        
        emit DelegationChanged(msg.sender, _delegatee);
    }
    
    /**
     * @dev Remove delegation
     */
    function clearDelegation() external {
        address currentDelegatee = delegations[msg.sender];
        
        // Only proceed if there's an active delegation
        if (currentDelegatee != address(0)) {
            // Update delegated power
            delegatedPower[currentDelegatee] -= governanceToken.balanceOf(msg.sender);
            
            // Clear delegation
            delegations[msg.sender] = address(0);
            
            emit DelegationChanged(msg.sender, address(0));
        }
    }
    
    /**
     * @dev Get the voting power of an address (own balance + delegated)
     * @param _voter Address to check voting power for
     * @return The total voting power
     */
    function getVotingPower(address _voter) external view returns (uint256) {
        return governanceToken.balanceOf(_voter) + delegatedPower[_voter];
    }

    /**
     * @dev Get a specific proposal by ID
     * @param _proposalId ID of the proposal
     * @return Proposal data
     */
    function getProposalById(uint256 _proposalId) external view returns (
        uint256 id,
        address creator,
        string memory title,
        string memory description,
        ProposalType proposalType,
        uint256 startTime,
        uint256 endTime,
        uint256 yesVotes,
        uint256 noVotes,
        uint256 abstainVotes,
        uint256 quorum,
        ProposalStatus status
    ) {
        if (_proposalId >= proposalCount) {
            revert ProposalNotFound();
        }

        Proposal storage proposal = proposals[_proposalId];
        
        return (
            proposal.id,
            proposal.creator,
            proposal.title,
            proposal.description,
            proposal.proposalType,
            proposal.startTime,
            proposal.endTime,
            proposal.yesVotes,
            proposal.noVotes,
            proposal.abstainVotes,
            proposal.quorum,
            proposal.status
        );
    }

    /**
     * @dev Get all proposals
     * @return Array of proposal data
     */
    function getProposals() external view returns (
        uint256[] memory ids,
        address[] memory creators,
        string[] memory titles,
        ProposalType[] memory proposalTypes,
        uint256[] memory startTimes,
        uint256[] memory endTimes,
        uint256[] memory yesVotes,
        uint256[] memory noVotes,
        uint256[] memory abstainVotes,
        ProposalStatus[] memory statuses
    ) {
        uint256 count = proposalCount;
        
        ids = new uint256[](count);
        creators = new address[](count);
        titles = new string[](count);
        proposalTypes = new ProposalType[](count);
        startTimes = new uint256[](count);
        endTimes = new uint256[](count);
        yesVotes = new uint256[](count);
        noVotes = new uint256[](count);
        abstainVotes = new uint256[](count);
        statuses = new ProposalStatus[](count);
        
        for (uint256 i = 0; i < count; i++) {
            Proposal storage proposal = proposals[i];
            
            ids[i] = proposal.id;
            creators[i] = proposal.creator;
            titles[i] = proposal.title;
            proposalTypes[i] = proposal.proposalType;
            startTimes[i] = proposal.startTime;
            endTimes[i] = proposal.endTime;
            yesVotes[i] = proposal.yesVotes;
            noVotes[i] = proposal.noVotes;
            abstainVotes[i] = proposal.abstainVotes;
            statuses[i] = proposal.status;
        }
        
        return (
            ids,
            creators,
            titles,
            proposalTypes,
            startTimes,
            endTimes,
            yesVotes,
            noVotes,
            abstainVotes,
            statuses
        );
    }

    /**
     * @dev Get the total number of proposals
     * @return Total number of proposals
     */
    function getProposalCount() external view returns (uint256) {
        return proposalCount;
    }

    /**
     * @dev Get the vote info for a voter on a proposal
     * @param _proposalId ID of the proposal
     * @param _voter Address of the voter
     * @return hasVoted Whether the address has voted
     * @return support How the address voted (if they did)
     */
    function getVoteInfo(uint256 _proposalId, address _voter) external view returns (
        bool hasVoted,
        VoteSupport support
    ) {
        if (_proposalId >= proposalCount) {
            revert ProposalNotFound();
        }

        Proposal storage proposal = proposals[_proposalId];
        
        return (
            proposal.hasVoted[_voter],
            proposal.votes[_voter]
        );
    }

    /**
     * @dev Execute a successful proposal
     * @param _proposalId ID of the proposal to execute
     */
    function executeProposal(uint256 _proposalId) external {
        if (_proposalId >= proposalCount) {
            revert ProposalNotFound();
        }

        Proposal storage proposal = proposals[_proposalId];
        
        // Ensure proposal is in Succeeded status
        if (proposal.status != ProposalStatus.SUCCEEDED) {
            revert("Proposal cannot be executed: not in SUCCEEDED state");
        }

        // Update status
        proposal.status = ProposalStatus.EXECUTED;
        
        // Execute calls if there are targets
        if (proposal.targets.length > 0) {
            for (uint256 i = 0; i < proposal.targets.length; i++) {
                (bool success, ) = proposal.targets[i].call{value: proposal.values[i]}(
                    proposal.calldata_[i]
                );
                
                if (!success) {
                    revert("Proposal execution failed");
                }
            }
        }
        
        // Emit event
        emit ProposalStatusChanged(_proposalId, ProposalStatus.EXECUTED);
    }

    /**
     * @dev Cancel a proposal (only creator can cancel)
     * @param _proposalId ID of the proposal to cancel
     */
    function cancelProposal(uint256 _proposalId) external {
        if (_proposalId >= proposalCount) {
            revert ProposalNotFound();
        }

        Proposal storage proposal = proposals[_proposalId];
        
        // Only creator can cancel
        if (msg.sender != proposal.creator) {
            revert("Only proposal creator can cancel");
        }
        
        // Cannot cancel if already executed, succeeded, defeated, or expired
        if (
            proposal.status == ProposalStatus.EXECUTED ||
            proposal.status == ProposalStatus.SUCCEEDED ||
            proposal.status == ProposalStatus.DEFEATED ||
            proposal.status == ProposalStatus.EXPIRED
        ) {
            revert("Proposal cannot be canceled in current state");
        }
        
        // Update status
        proposal.status = ProposalStatus.CANCELED;
        
        // Emit event
        emit ProposalStatusChanged(_proposalId, ProposalStatus.CANCELED);
    }
}
